(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{267:function(n,e,o){"use strict";o.r(e);var t=o(77),r=o.n(t),l={data:function(){return{link:"content12",prekiji:"\n## 内容\n　以前の記事([GraphQL APIでDBアクセスを大量に発生させる攻撃手法について](http://localhost:3000/blog/content10))をうけて、\n攻撃手法に対する対策を考えて試してみたという記事\n\n## 使用したモジュール\n- [apollo-server](https://www.apollographql.com/)\n- [graphql](https://graphql.org/)\n- [graphql-cost-analysis](https://github.com/pa-bru/graphql-cost-analysis)\n- [graphql-query-complexity](https://github.com/slicknode/graphql-query-complexity)\n- [graphql-depth-limit](https://github.com/stems/graphql-depth-limit)\n\n## 長くて読まないよという人に\n\n- [ソースコード](https://github.com/zodiac-G12/attack-gql-server)\n\n## 悪意あるクエリ対策\n　例えば以下のような悪意あるクエリがあるとする。\n```\nquery {\n  authors {\n    books {\n      author {\n        books {\n          author {\n            books {\n              ...\n              author {\n                name\n              }\n              ...\n            }\n          }\n        }\n      }\n    }\n  }\n```\n\nこれに対処するために、コスト(Cost)或いは複雑性(Complexity)、ネストの深さという指標を用いて、レスポンスを切り分けるという方法がある。\n\n　**graphql-cost-analysis**, **graphql-query-complexity** は上記のコスト或いは複雑性を定義し、閾値の超えたクエリに対してはエラーを返すという方法を提供する。\n\n　**graphql-depth-limit** に関してはネストの深さで切り分けをする方法を提供する。\n\n　具体的なコードを以下に書いていく。\n\n## graphql-cost-analysis\n\n```typescript\nimport costAnalysis from 'graphql-cost-analysis';\n\nexport const defaultCost: number = 1;\n\nexport const costAnalyzer = (maximumCost: number) => costAnalysis({\n  defaultCost,\n  maximumCost,\n  onComplete: (cost: number) => {\n    console.log('Query Cost:', cost);\n  },\n});\n```\n<br>\n\n## graphql-query-complexity\n\n```typescript\nimport queryComplexity, { simpleEstimator } from 'graphql-query-complexity';\n\nexport const defaultComplexity: number = 1;\n\nexport const queryComplexier = (maximumComplexity: number) => queryComplexity({\n  estimators: [\n    simpleEstimator({defaultComplexity})\n  ],\n  maximumComplexity,\n  onComplete: (complexity: number) => {\n    console.log('Query Complexity:', complexity);\n  },\n});\n```\n<br>\n\n## graphql-depth-limit\n\n```typescript\nimport depthLimit from 'graphql-depth-limit';\n\nexport const depthLimiter = (maxDepth: number) => depthLimit(\n  maxDepth,\n  {},\n  depths => console.log(depths)\n);\n```\n<br>\n\n## ルールの適用\n　以下のように **validationRules**に配列の要素として渡す。\n\n> 公式ドキュメント: https://www.apollographql.com/docs/apollo-server/api/apollo-server/#validationrules\n\n```typescript\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  validationRules: [\n    depthLimiter(9),\n    queryComplexier(10),\n    costAnalyzer(10),\n  ],\n});\n```\n\n<br>\n\n## クエリに対する各値の検証例\n\n```\nquery {\n  books {\n    author {\n      books {\n        title \n      }\n    }\n  }\n}\n```\n=&gt;\nQuery Depth: 3,\nQuery Complexity: 4,\nQuery Cost: 4\n\n```\nquery {\n  authors {\n    id\n    books {\n      id\n    \tauthor {\n        id\n        books {\n          id\n          title\n        }\n      }\n    }\n  }\n}\n```\n\n=&gt;\nQuery Depth: 4,\nQuery Complexity: 9,\nQuery Cost: 9\n\n```\nquery {\n  authors {\n    books {\n      author {\n        books {\n          author {\n            books {\n              author {\n                books {\n                  author {\n                    books {\n                      title\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n=&gt;\nError: exceeds maximum operation depth of 9\n\n```\nquery {\n  authors {\n    id\n    books {\n      id\n      title\n    \tauthor {\n        id\n        name\n        books {\n          id\n          title\n        }\n      }\n    }\n  }\n}\n```\n\n=&gt;\nError: The query exceeds the maximum complexity of 10. Actual complexity is 11\n\n　以上のことから、簡単な見分け方法として、「authors, id, title」などの単語の数が **Complexity, Cost** で、\n「{}」のペアの数(ネストの深さ)が **Depth** であると分かる。\n\n## おおよその問題解決とはなりうるが\n　以上のことから、閾値を設けることで、ComplexityやDepthが100万といったクエリは防ぐことができる。\nしかし、私はもっと簡単に「books->authors->books」や「books->authors->...->books->authors」という表現の含まれるクエリを特定で防げば良いと考えた。\n\n## 特定表現のクエリのブロック\n\n```typescript\n// DISABLE disallowCycle -> INVALID: author -> books -> (shops -> authors -> shops) -> books\n// DISABLE disallowPattern -> INVALID: author -> books -> (shops -> countries) -> authors -> shops -> books -> (shops -> countries)\nconst loopCheck = (beforeName, selectionSet, transitionReference, disallowCycle, disallowPattern) => {\n  if (!selectionSet) {\n    return true;\n  }\n\n  const nowName = selectionSet.selections[0].name.value;\n  if (disallowPattern && beforeName && nowName) {\n    if (!transitionReference[beforeName]) {\n      transitionReference[beforeName] = [];\n    }\n    if (!transitionReference[beforeName].includes(nowName)) {\n      transitionReference[beforeName].push(nowName);\n    } else {\n      throw new Error(`Pattern is Already Exist: ${beforeName} -> ${nowName}`);\n    }\n  }\n\n  const nextName = selectionSet.selections[0].selectionSet?.selections[0].name.value;\n\n  console.log(beforeName, nowName, nextName, selectionSet.selections[0]);\n  if (disallowCycle && beforeName === nextName) {\n    throw new Error(`This is Looped Evil Query: beforeName: ${beforeName}, nowName: ${nowName}, nextName: ${nextName}`);\n  }\n  return loopCheck(nowName, selectionSet.selections[0].selectionSet, transitionReference, disallowCycle, disallowPattern);\n}\n\nexport const orginalRules = (info, disallowCycle, disallowPattern) => {\n  return loopCheck(info.fieldNodes[0].name.value, info.fieldNodes[0].selectionSet, {}, disallowCycle, disallowPattern);\n}\n```\n「disallowCycle: true -> (shops -> authors -> shops)といった繰り返しを不正とみなす」\n「disallowPattern: true -> (shops -> countries)といった表現が再び出現した際に不正とみなす」\n\n挿入場所を以下に示す。\n\n```typescript\nconst resolvers = {\n  Query: {\n    books (parent, args, context, info) {\n      // ここ！\n      orginalRules(info, true, true);\n      return books;\n    },\n    ...\n```\n<br>\n\n## 実際に動かしてみる\n\n```\nquery {\n  books {\n   \tauthor {\n      books {\n        title \n      }\n    }\n  }\n}\n```\n\nError: This is Looped Evil Query: beforeName: books, nowName: author, nextName: books\n\n```\n# disallowCycleをfalseにする\nquery {\n  authors {\n    books {\n      author {\n        books {\n          author {\n            name\n          }\t\t\n        }\n      }\n    }\n  }\n}\n```\n\nError: Pattern is Already Exist: books -> author\n\n　以上の実装はあくまでコンセプトなので、実用には耐え得ないので注意。\n例として、\n\n```\nquery {\n  books {\n    id\n   \tauthor {\n      id\n      books {\n        id\n        title \n      }\n    }\n  }\n}\n```\n\nとやると上記のルールを通過してしまう実装になっている。\n順当にやるなら、graphql-query-complexityの実装を参考にしたりしながら実装した方が良いであろう。\n> selectionSet: [Apolloの公式ドキュメント](https://www.apollographql.com/blog/the-anatomy-of-a-graphql-query-6dffa9e9e747/)\n\n## まとめ\n　ドキュメントを読んで実際に手を動かして試してみることの大事さを実感した。\n上記のクエリの繰り返しやパターンの防止の実装は、調べた限りなさそうだったので、\n開拓者のような気分を勝手に味わったといった所感である。\n"}},computed:{kiji:function(){return r()(this.prekiji)}},components:{DefaultArticle:function(){return o.e(0).then(o.bind(null,283))}}},m=o(20),component=Object(m.a)(l,(function(){var n=this.$createElement,e=this._self._c||n;return e("div",[e("DefaultArticle",{attrs:{content:{link:this.link,kiji:this.kiji}}})],1)}),[],!1,null,null,null);e.default=component.exports}}]);