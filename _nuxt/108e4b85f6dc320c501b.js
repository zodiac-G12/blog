(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{265:function(n,o,t){"use strict";t.r(o);var r=t(77),e=t.n(r),l={data:function(){return{link:"content10",prekiji:'\n## 内容\n　GraphQL APIでDBアクセスを大量に発生させる攻撃手法について、公式ドキュメントや参考記事をもとに、実際に攻撃が可能なのか確かめてみたという記事。\n\n## 想定読者\n　GraphQLについて興味があり、ある程度の知識がある人。JavaScriptについてある程度知識がある人。\n\n## 動機\n　ある記事を読んでいて、気になったと同時に、全く考慮したことがない事柄で青ざめたので、実際に実装して試してみたかった。\n\n## 参考文献\n　[GraphQL API を悪意あるクエリから守る手法](https://yigarashi.hatenablog.com/entry/graphql-query-analysis)\n\n## 使用したモジュール\n- [apollo-server](https://www.apollographql.com/)\n- [graphql](https://graphql.org/)\n\n## 実装\n　[公式](https://www.apollographql.com/docs/apollo-server/data/resolvers/)を参考にして以下のように実装する。\n\n```javascript\nconst { ApolloServer, gql } = require(\'apollo-server\');\n\nconst typeDefs = gql`\n  type Book {\n    id: Int!\n    title: String!\n    author: Author!\n  }\n\n  type Author {\n    id: Int!\n    name: String!\n    books: [Book!]!\n  }\n\n  type Query {\n    books: [Book]\n    authors: [Author]\n  }\n`;\n\n// DBのテーブルとみなす\nconst books = [\n  {\n    id: 1,\n    title: \'The Awakening\',\n    author: {\n      id: 1,\n    }\n  },\n  {\n    id: 2,\n    title: \'City of Glass\',\n    author: {\n      id: 2,\n    }\n  },\n];\n\n// DBのテーブルとみなす\nconst authors = [\n  {\n    id: 1,\n    name: \'Kate Chopin\',\n    books: [\n      {\n        id: 1,\n      },\n    ],\n  },\n  {\n    id: 2,\n    name: \'Paul Auster\',\n    books: [\n      {\n        id: 2,\n      },\n    ],\n  }\n];\n\n// DBへの想定アクセス回数\nlet dbCount = 0;\n\nconst findByIdBook = (id) => {\n  dbCount += books.length;\n  console.log(dbCount);\n  return books.filter(book => book.id === id)[0];\n}\n\nconst findbyIdAuthor = (id) => {\n  dbCount += authors.length;\n  console.log(dbCount);\n  return authors.filter(author => author.id === id)[0];\n}\n\nconst resolvers = {\n  Query: {\n    books: () => books,\n    authors: () => authors,\n  },\n  Book: {\n    author (parent) {\n      return findbyIdAuthor(parent.author.id);\n    },\n  },\n  Author: {\n    books (parent) {\n      return parent.books.map(book => findByIdBook(book.id));\n    }\n  }\n};\n\nconst server = new ApolloServer({ typeDefs, resolvers });\n\nserver.listen().then(({ url }) => {\n  console.log(`🚀  Server ready at ${url}`);\n});\n```\n\n重要なのは、BookとAuthorが互いに相互参照している点である。\n\nこれは公式GraphQLのベストプラクティスの、\n\nbookがauthorのidなりを持っていなるなら、authorの実体を引けるようにする方が良いという思想に基づいている。\n\n## 実際に実行\n\n以上のBookとAuthorが互いに相互参照している方針に従ってスキーマを設計すると、\n\nbook --\x3e author --\x3e books --\x3e author --\x3e books ... といったように無限に循環する構造を作ることができる。\n\nこれを利用すると以下のようなクエリを書くことができる。\n\n```\nquery {\n  authors {\n    books {\n      author {\n        books {\n          author {\n            books {\n              ...\n              author {\n                name\n              }\n              ...\n            }\n          }\n        }\n      }\n    }\n  }\n```\n\nレスポンス\n\n```\n{\n  "data": {\n    "authors": [\n      {\n        "books": [\n          {\n            "author": {\n              "books": [\n                {\n                  "author": {\n                    "books": [\n                      {\n                        ...\n                        "author": {\n                          "name": "Kate Chopin"\n                        }\n                        ...\n                      }\n                    ]\n                  }\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n```\nおよそ**558回**ネストしたところ、DBアクセス概算は**2232回**であった。\n\n数式で言うと、\n\n(ネストの回数) × 4 = (DBアクセス回数)\n\nである。\n\n> 注意: 上の数式はbooksとauthorsのデータが上のソースコードの条件の時のみ\n\n> また(DBアクセス回数)はあくまでも目安であり、実際とは異なる場合もある\n\nそして、上限を特に設けていないため、何回でもクエリを投げられるし、再現なくDBアクセス回数を増やすことができる。\n\n故にこのままの仕組みで表に出すと非常に危険なことがわかる。\n\n## 危険性\n　例えば具体的な話で、「あのGraphQL使っているサービスを潰したい」と思ったとして、\n\nこの攻撃に関して対策がされていないと、DBアクセスを大量にして、\n\n**「サーバーをダウンさせてサービス停止させる」**\n\n**「DBアクセス毎に課金するサービスを用いていた場合に課金をめちゃくちゃさせる」**\n\nなどができてしまう恐れがある。\n\n　また、apollo-graphqlの公式サイトにも特に注意書きなどがなく、初心者は知らない間にこの問題に陥りやすいのではと考察している。\n\n## 対策方法案\n　クエリの複雑性の数値(complexity)を算出し、閾値を設けて実行を切り分けるという方法があるらしい。\n以下はその方針に則ったツール。\n\n- [graphql-query-complexity](https://github.com/slicknode/graphql-query-complexity)\n- [graphql-cost-analysis](https://github.com/pa-bru/graphql-cost-analysis)\n\n対策に関してはまた今度記事を書こうと思う。\n'}},computed:{kiji:function(){return e()(this.prekiji)}},components:{DefaultArticle:function(){return t.e(0).then(t.bind(null,283))}}},h=t(20),component=Object(h.a)(l,(function(){var n=this.$createElement,o=this._self._c||n;return o("div",[o("DefaultArticle",{attrs:{content:{link:this.link,kiji:this.kiji}}})],1)}),[],!1,null,null,null);o.default=component.exports}}]);